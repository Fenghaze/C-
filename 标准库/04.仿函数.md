# 仿函数

【../C++基础/STL/STL函数对象.md】

==重载调用()运算符==

==仿函数只为算法服务==



C++提供了24个仿函数，分为以下三类：

- 算术仿函数：`+`，`-`，`*`，`/`等运算

- 逻辑运算仿函数：`&&`，`||`等逻辑运算

- 比较关系仿函数：`>`，`<`，`==`等比较运算

C++提供的仿函数继承了基类`binary_function`、`unary_function`

```c++
// 基类：一个操作数
template<class Arg, class Result>
struct unary_function
{
    typedef Arg argument_type;
    typedef Result result_type;
};

// 基类：两个操作数
template<class Arg1, class Arg2, class Result>
struct binary_function
{
    typedef Arg1 first_argument_type;
    typedef Arg2 second_argument_type;
    typedef Result result_type;
};

// C++提供的比较关系仿函数
template<class T>
struct greater:public binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const { return x > y; }
};

// C++提供的比较关系仿函数，继承binary_function后，仿函数可适配（适配器可以使用仿函数）
template<class T>
struct less:public binary_function<T, T, bool>
{
    bool operator()(const T& x, const T& y) const { return x < y; }
};
```



# 使用仿函数

```c++
bool myfunc(int i, int j) { return i > j; }

// 自定义的仿函数没有继承基类
struct myclass
{
    bool operator()(int i, int j) { return i < j; }
}myobj;

sort(v.begin(), v.end());					//使用默认的排序方式

sort(v.begin(), v.end(), myfunc);			//使用普通函数

sort(v.begin(), v.end(), myobj);			//使用仿函数（类对象）

sort(v.begin(), v.end(), less<int>());		//C++提供的仿函数，需要使用()创建一个临时对象

sort(v.begin(), v.end(), greater<int>());	//C++提供的仿函数，需要使用()创建一个临时对象
```

==注意！！！==

C++提供的仿函数拥有继承关系，可以让**适配器或算法使用C++提供的仿函数**

自定义的仿函数一般没有继承关系，要想让**适配器使用自定义的仿函数**或**算法使用仿函数**，需要继承合适的基类



# 适配器

把既有的东西进行改造，使用既有的方法生成适配器

适配器都是采用==内含==的方法来进行改造

根据改造的对象，适配器可以分为以下三类：

- 容器适配器（内含容器）：如成stack、queue 【./02.容器.md-容器适配器】

- 迭代器适配器（内含迭代器）
- 函数适配器（内含仿函数）：将仿函数进行修饰，修饰后仍然是一个仿函数，如binder2nd，not1



# 函数适配器

## binder2nd

效果：改造比较关系仿函数，为其绑定一个阈值

```c++
// binder2nd 函数适配器
template<class Operation>
class binder2nd:public unary_function<typename Operation::first_argument_type, typename Operation::result_type>
{
protected:
    Operation op;	//记录传来的比较关系仿函数，less<int>
    //获取仿函数的second_arugment_type
    typename Operation::second_argument_type value;	//记录传来的阈值，40
public:
    // 构造函数
    binder2nd(const Operation& x, const typename Operation::second_argument_type& y): op(x), value(y) {}
    // 重载调用运算符
	typename Operation::result_type operator()(const typename Operation::first_argument_type& x) const
    {
        return op(x, value);
    }
}

// 辅助函数，包装函数适配器
template<class Operation, class T>
inline binder2nd<Operation> bind2nd(const Operation& op, const T& x)
{
    //编译器获取仿函数的second_arugment_type
    typedef typename Operation::second_arugment_type arg2_type;
    // arg2_type(x)，编译器会检查 x 是否可以转换为 arg2_type 类型
    return binder2nd<Operation>(op, arg2_type(x));	// 初始化对象
}

// count_if
template<class InputIterator, class Predicate>
typename iterator_traits<InputIterator>::difference_type count_if(InputIterator first, InputIterator last, Predicate pred)
{
    typename iterator_traits<InputIterator>::difference_type n = 0;
    for(; first!=last; ++first)
    	if(pred(*first))	//条件判断函数
            ++n;
    return n;
}

// 使用
count_if(vi.begin(), vi.end(), bind2nd(less<int>(), 40));	//调用 binder2nd()
```



## not1

传入一个函数适配器，效果取反

```c++
template<class Predicate>
class unary_negate:public unary_function<typename Predicate::argument_type, bool>
{
protected:
    Predicate pred;
public:
    explicit unary_negate(const Predicate& x): pred(x){}
    bool operator()(const typename Predicate::arugment_type& x) const
    {
        return !pred(x);
    }
};

template<class Predicate>
inline unary_negate<Predicate> not1(const Perdicate& pred)
{
    return unary_negate<Predicate>(pred);
}

// 使用
count_if(vi.begin(), vi.end(), not1(bind2nd(less<int>(), 40)));
```



# 新型适配器 bind

`std::bind`可以绑定：

- 1、functions（函数），_1表示第一个参数
- 2、function objects（仿函数）
- 3、member functions，参数_1必须是某个object
- 4、data members，参数_1必须是某个object

返回值是一个function object ret，调用ret相当于调用上述1，2，3，或相当于取出4

```c++
// 普通函数
double my_divide(double x, double y) { return x/y; }

// 类
struct MyPair
{
    double a, b;
    double mutiply() { return a*b; }
};

using namespace std::placeholders;

auto fn1 = bind(my_divide, 10, 2);	//绑定普通函数
fn1();	//	10/2=5

auto fn2 = bind(my_divide, _1, 2);
fn2(4);	//	4/2=4


MyPair ten_two{10, 2};	// 实例化一个类对象
auto fn3 = bind(&MyPair::multiply, _1);	// 绑定成员函数，需要使用&
fn3(ten_two);	// 10*2=20

auto fn4 = bind(&MyPair::a, ten_two);	// 绑定成员变量a，指定参数_1
fn3();	// a=10，自动获取ten_two.a

auto fn4 = bind(&MyPair::b, _1);	// 绑定成员变量b，参数_1
fn3(ten_two);	// b=2，自动获取ten_two.b

vector<int> v {15,16,7,35,44};
int n = count_if(v.begin(), v.end(), not1(bind2nd(less<int>(), 50)));

auto fn = bind(less<int>(), _1, 50);	//保留第一实参，编译时v中的每个元素作为第一实参与50进行比较
count_if(v.begin(), v.end(), fn);
// count_if(v.begin(), v.end(), bind(less<int>(), _1, 50));
```



# 迭代器适配器


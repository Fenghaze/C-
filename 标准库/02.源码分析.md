Linux下STL源码在`/usr/include/c++/9/bits`

# OOP & GP

- OOP（Object-Oriented Programming）
  - 一个类中有方法和属性
- GP（Generic Programming）
  - 类中的方法和属性是分开的，方法（算法）在外部实现，是全局的



# 基础 

`./C++基础/04类的高级用法.md`

## 操作符重载

## 模板

`./C++面向对象高级开发/03面向对象续.md`



# 分配器

实质调用`malloc`，`free`



# 容器

## list

实质：实现的是双向循环链表

size：8（两个指针）

源代码中存在：

- node：链表节点
- iterator：泛化指针（至少有5个typedef，重载指针运算符）



# 迭代器

定义迭代器时，必须提供5种迭代器相关类型，以便算法使用：

```c++
template<class _Tp>
struct _List_iterator
{
    typedef ptrdiff_t							difference_type;
    typedef std::bidirectional_iterator_tag		iterator_category;
    typedef _Tp									value_type;
    typedef _Tp*								pointer;
    typedef _Tp&								reference;
    ...
};

// 算法使用迭代器
template<typename I>
inline void algorithm(I first, I last)
{
    I::iterator_category;
    I::difference_type;
    I::value_type;
    I::pointer;
    I::reference;
}
```



## Traits 萃取

`stl_iterator.h`

当算法使用一般的指针而不是迭代器（模板类）时，需要使用萃取作为中介

`iterator_traits`用以分离迭代器和一般指针

```c++
// 1，迭代器
template<class I>
struct iterator_traits
{
    typedef typename I::value_type 			value_type;
    typedef typename I::difference_type 	difference_type;
    typedef typename I::iterator_category	iterator_category;
    typedef typename I::pointer 			pointer;
    typedef typename I::reference 			reference;
}

// 2，一般指针
template<class T>
struct iterator_traits<T*> // 范围偏特化，限定参数类型
{
    typedef T 							value_type;
    typedef ptrdiff_t					difference_type;
    typedef random_access_iterator_tag	iterator_category;
    typedef T*							pointer;
    typedef T&							reference;
}

// 3，const指针
template<class T>
struct iterator_traits<const T*>
{
    typedef T 							value_type;	// 是T，而不是const T
    typedef ptrdiff_t					difference_type;
    typedef random_access_iterator_tag	iterator_category;
    typedef const T*					pointer;
    typedef const T&					reference;
}

// 算法使用迭代器or一般指针
template<typename I, ...>
inline void algorithm(...)
{
    typename iterator_traits<I>::value_type v1;
    // 如果I是迭代器，调用1
    // 如果I是一般指针，调用2
    // 如果I是const指针，调用3
}
```

